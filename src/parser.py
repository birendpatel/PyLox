# Copyright (C) 2021 Biren Patel
# MIT License
# Generate an abstract syntax tree via a recusive descent parser

from src.error import ErrorHandler
from src.tokenizer import Token, TokenType
from src.node import Binary, Unary, Literal, Grouping

class Parser():
    def __init__(self):
        """\
        convert a list of tokens to an abstract syntax tree
        @i: tokens index
        @ast: abstract syntax tree generated by self.expression()
        """
        self.err = ErrorHandler()
        self.tokens = []
        self.i = 0
        self.ast = None

    def curr_type(self):
        """\
        helper function: returns token type of token at current list index
        """
        token = self.tokens[self.i]
        return token.type

    def curr_token(self):
        """\
        helper function: syntactic sugar to fetch current token
        """
        return self.tokens[self.i]

    def advance(self):
        """\
        helper function: syntactic sugar for iteration over the tokens list
        """
        assert(self.i + 1 < len(self.tokens))
        self.i += 1

    def prev_token(self):
        """\
        helper function: syntactic sugar to fetch previous token
        """
        assert(self.i - 1 >= 0)
        return self.tokens[self.i - 1]

    def parse(self, tokens, limit = 3):
        """\
        recursive descent entry point
        @tokens: list of tokens provided by lexical analysis, tokens[-1] == EOF
        @limit: internal ErrorHandler limit
        """
        self.err = ErrorHandler(limit)
        self.tokens = tokens
        self.i = 0
        self.ast = self.expression()

        return (self.ast, self.err)

    def expression(self):
        """\
        dummy method used to encode the lox grammar explicity in the source.
        <expression> := <equality>
        """
        return self.equality()

    def equality(self):
        left = self.comparison()
        return left

    def comparison(self):
        left = self.term()
        return left

    def term(self):
        left = self.factor()
        return left

    def factor(self):
        left = self.unary()
        return left

    def unary(self):
        """\
        <unary> := ("!" | "-") <unary> | <primary>
        """
        if self.curr_type() in [TokenType.BANG, TokenType.MINUS]:
            self.advance()
            return Unary(self.prev_token(), self.unary())

        return self.primary()

    def primary(self):
        if self.curr_type() in [TokenType.NUMBER]:
            expr = Literal(self.curr_token())
            self.advance()
            return expr
